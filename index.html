<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Gong Timer — Animated UI (v2)</title>
<link rel="preload" as="audio" href="./individual_gong.mp3">
<link rel="preload" as="audio" href="./final_gongs.mp3">
<style>
  /* =====================
     Theme & Base Styles
     ===================== */
  :root {
    --bg: #0b0e14;        /* deeper background */
    --bg2: #0f1420;       /* panel contrast */
    --ink: #e9eef7;
    --muted: #8c99ad;
    --accent: #6ee7ff;
    --accent2: #449fef;
    --glow: 0 0 24px rgba(110, 231, 255, .25);
  }
  html, body {
    height: 100%;
    background: radial-gradient(1200px 800px at 20% -10%, rgba(68,159,239,.15), transparent 60%),
                radial-gradient(1400px 900px at 110% 120%, rgba(110,231,255,.12), transparent 60%),
                linear-gradient(180deg, var(--bg), #07090d 60%);
    color: var(--ink);
    margin: 0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
    overflow: hidden;
  }
  * { box-sizing: border-box; }

  /* =====================
     Layout & Panels (glass + subtle animation)
     ===================== */
  .wrap {
    height: 100vh;
    max-width: 980px;
    margin: 0 auto;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 14px;
  }
  .panel {
    position: relative;
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 16px;
    padding: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.04);
    backdrop-filter: saturate(120%) blur(6px);
    animation: panelIn .6s cubic-bezier(.2,.8,.2,1) both;
  }
  @keyframes panelIn { from { transform: translateY(8px); opacity: 0 } }


  /* =====================
     Buttons (micro‑interaction)
     ===================== */
  button {
    appearance: none;
    background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
    border: 1px solid rgba(255,255,255,0.14);
    color: var(--ink);
    padding: 10px 14px;
    border-radius: 12px;
    cursor: pointer;
    font-weight: 700;
    font-size: 14px;
    letter-spacing: .2px;
    transition: transform .08s ease, box-shadow .2s ease, border-color .2s ease, background .2s ease;
  }
  button:hover { border-color: rgba(110,231,255,.5); box-shadow: var(--glow); }
  button:active { transform: translateY(1px) scale(.99); }
  .btn-accent { color: #061014; background: linear-gradient(180deg, rgba(110,231,255,.95), rgba(68,159,239,.9)); border-color: rgba(110,231,255,.85); box-shadow: 0 6px 24px rgba(110,231,255,.3); }
  .btn-accent:hover { filter: saturate(115%); }
  .btn-disabled { opacity: 0.4; cursor: not-allowed; }
  .btn-disabled:hover { border-color: rgba(255,255,255,0.14); box-shadow: none; }


  /* =====================
     Canvas Stage
     ===================== */
  .canvas-panel {
    flex: 1;
    min-height: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }
  .next-gong-top {
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    color: var(--accent2);
    font-size: 24px;
    font-weight: 800;
    text-align: center;
    z-index: 2;
    font-variant-numeric: tabular-nums;
    text-shadow: 0 1px 0 rgba(0,0,0,.4);
    transition: color .3s ease, transform .4s cubic-bezier(.2,.8,.2,1);
  }
  .next-gong-top.pulse { transform: translateX(-50%) scale(1.02); }
  .paused-note { font-size: 20px; font-weight: 600; color: var(--muted); margin-top: 2px; }
  .time-text { font-size: 40px; font-weight: 800; }

  .corner-btn {
    position: absolute;
    bottom: 12px;
    z-index: 3;
    padding: 8px;
    font-size: 16px;
    width: 90px;
    height: 90px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .corner-btn-left {
    left: 12px;
  }
  .corner-btn-right {
    right: 12px;
  }

  canvas { 
    width: 100%;
    height: 100%;
    max-width: min(100%, 100vh - 300px);
    max-height: min(100%, 100vh - 300px);
    display: block; 
    touch-action: none; 
    cursor: pointer;
    object-fit: contain;
    filter: drop-shadow(0 40px 80px rgba(0,0,0,.35));
  }

  /* =====================
     Gong list chips
     ===================== */
  .sub { color: var(--muted); font-size: 13px; margin-bottom: 8px; }
  .list {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(92px, 1fr));
    gap: 8px;
  }
  .chip {
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
    border: 1px solid rgba(255,255,255,0.14);
    border-radius: 999px;
    padding: 7px 10px;
    font-variant-numeric: tabular-nums;
    text-align: center;
    cursor: pointer;
    font-size: 14px;
    transition: transform .12s ease, box-shadow .25s ease, border-color .2s ease;
    user-select: none;
  }
  .chip:hover { transform: translateY(-1px); border-color: rgba(110,231,255,.6); box-shadow: var(--glow); }
  .chip:active { transform: translateY(0); }

  @media (max-height: 640px) {
    .sub { display: none; }
    .panel { padding: 10px; }
    button { padding: 8px 12px; font-size: 13px; }
  }
</style>
</head>
<body>
<div class="wrap">

  <div class="panel canvas-panel">
    <div id="nextGongDisplay" class="next-gong-top"></div>
    <button id="rew" class="corner-btn corner-btn-left">- 30s</button>
    <button id="ff" class="corner-btn corner-btn-right">+ 30s</button>
    <canvas id="dial" width="640" height="640" aria-label="Radial audio scrubber"></canvas>
  </div>

  <div class="panel" style="display: none;">
    <div class="sub">Gongs (tap to jump)</div>
    <div id="gongList" class="list"></div>
  </div>
</div>

<script>
(() => {
  // =====================
  // Config & Audio Assets
  // =====================
  const gongTimes = ["04:43","09:23","14:06","18:48","23:30","28:12","32:54","37:38"].map(toSeconds);
  const totalDuration = gongTimes[gongTimes.length - 1]; // 37:38
  const GONG_DELAY = 3880; // 3.88 seconds in milliseconds

  const GONG_POOL_SIZE = 5; // overlapping rings
  const gongPool = [];
  let gongIndex = 0;
  let audioPrimed = false;
  let finalGongAudio = null;

  // =====================
  // DOM
  // =====================
  const ffBtn = document.getElementById('ff');
  const rewBtn = document.getElementById('rew');
  const dial = document.getElementById('dial');
  const ctx = dial.getContext('2d');
  const gongList = document.getElementById('gongList');
  const nextGongDisplay = document.getElementById('nextGongDisplay');

  // =====================
  // State
  // =====================
  let isPlaying = false;
  let currentTime = 0;      // logic time (audio/triggers)
  let displayTime = 0;      // eased UI time
  let startTimestamp = 0;
  let pausedTime = 0;
  let rafId = null;
  let updateInterval = null;
  let dragging = false;
  let lastGongIndex = -1;
  let gongTimeouts = [];
  let pointerX = 0;
  let pointerY = 0;

  // Drag rotation state (for fixed indicator UX)
  let dragStartAngle = 0; // angle at pointerdown
  let dragStartTime = 0;  // time at pointerdown

  // Easing factor for displayTime (0..1). Higher = snappier.
  const EASE = 0.18;

  // Set scrub direction preference: true => clockwise increases time
  const SCRUB_CLOCKWISE_INCREASES = true;

  // Drawing metrics
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  // Pulse FX on each gong
  const pulses = []; // {t: timestamp(ms), life: 800}
  const PULSE_LIFE = 820;

  // =====================
  // Utilities
  // =====================
  function toSeconds(mmss) {
    const [m, s] = mmss.split(':').map(Number);
    return (m||0) * 60 + (s||0);
  }
  function syncDisplayToCurrent() { displayTime = currentTime; }
  function fmt(secs) {
    secs = Math.max(0, Math.floor(secs || 0));
    const m = Math.floor(secs / 60);
    const s = secs % 60;
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }

  const TAU = Math.PI * 2;
  const START_ANGLE = -Math.PI / 2; // fixed indicator at top

  function angleForTime(time, duration) {
    return START_ANGLE + (time / Math.max(duration, 0.001)) * TAU;
  }
  function timeForAngle(angle, duration) {
    const norm = (angle - START_ANGLE + TAU) % TAU;
    return (norm / TAU) * duration;
  }
  function normAngle(a) {
    let x = (a + Math.PI) % (2*Math.PI);
    if (x < 0) x += 2*Math.PI;
    return x - Math.PI; // -> [-PI, PI)
  }
  function angleFromPointer(ev) {
    const rect = dial.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    const cx = rect.width  / 2;
    const cy = rect.height / 2;
    return Math.atan2(y - cy, x - cx);
  }
  function distanceFromCenter(ev) {
    const rect = dial.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    const cx = rect.width  / 2;
    const cy = rect.height / 2;
    return Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
  }

  // =====================
  // Audio setup
  // =====================
  function createGongPool() {
    if (gongPool.length) return; // already created
    for (let i = 0; i < GONG_POOL_SIZE; i++) {
      const a = new Audio('./individual_gong.mp3');
      a.preload = 'auto';
      gongPool.push(a);
    }
    finalGongAudio = new Audio('./final_gongs.mp3');
    finalGongAudio.preload = 'auto';
  }
  async function primeAudioIfNeeded() {
    if (audioPrimed) return;
    createGongPool();
    try {
      for (const a of gongPool) {
        a.muted = true; await a.play(); a.pause(); a.currentTime = 0; a.muted = false;
      }
      if (finalGongAudio) {
        finalGongAudio.muted = true; await finalGongAudio.play(); finalGongAudio.pause(); finalGongAudio.currentTime = 0; finalGongAudio.muted = false;
      }
      audioPrimed = true;
    } catch (err) {
      console.warn('Audio prime failed:', err);
    }
  }
  function playGongSound() {
    if (!audioPrimed || !gongPool.length) return;
    const a = gongPool[gongIndex];
    gongIndex = (gongIndex + 1) % gongPool.length;

    // Add pulse animation for each gong sound
    pulses.push({ t: performance.now() });

    try { a.currentTime = 0; a.play().catch(e => console.warn('play() blocked:', e)); }
    catch (e) { console.warn('play error:', e); }
  }
  function playMultipleGongs(isLastGong = false) {
    gongTimeouts.forEach(timeout => clearTimeout(timeout));
    gongTimeouts = [];

    // Header nudge
    nextGongDisplay.classList.add('pulse');
    setTimeout(() => nextGongDisplay.classList.remove('pulse'), 280);

    if (isLastGong && finalGongAudio) {
      try { finalGongAudio.currentTime = 0; finalGongAudio.play().catch(e => console.warn('final gong play() blocked:', e)); }
      catch (e) { console.warn('final gong play error:', e); }
    } else {
      const numGongs = 3;
      playGongSound();
      for (let i = 1; i < numGongs; i++) {
        const timeout = setTimeout(() => playGongSound(), GONG_DELAY * i);
        gongTimeouts.push(timeout);
      }
    }
  }

  // =====================
  // Build gong list (defined BEFORE use)
  // =====================
  function buildGongList() {
    gongList.innerHTML = '';
    gongTimes.forEach((sec, i) => {
      const div = document.createElement('div');
      div.className = 'chip';
      div.textContent = `${i+1} • ${fmt(sec)}`;
      div.title = 'Jump to ' + fmt(sec);
      div.addEventListener('click', async () => {
        await primeAudioIfNeeded();
        currentTime = Math.min(Math.max(sec - 0.75, 0), totalDuration);
        pausedTime = currentTime;
        lastGongIndex = i - 1; // so this one will fire naturally
        gongTimeouts.forEach(timeout => clearTimeout(timeout));
        gongTimeouts = [];
        if (isPlaying) startTimestamp = performance.now();
        else syncDisplayToCurrent();
        updateButtonStates();
        draw();
      });
      gongList.appendChild(div);
    });
  }

  // =====================
  // Timer
  // =====================
  function updateTime() {
    if (isPlaying && !dragging) {
      const elapsed = (performance.now() - startTimestamp) / 1000;
      currentTime = Math.min(pausedTime + elapsed, totalDuration);

      // Trigger gongs when crossing timestamps
      const currentGongIndex = gongTimes.findIndex(t => currentTime >= t && currentTime < t + 0.5 && lastGongIndex < gongTimes.indexOf(t));
      if (currentGongIndex !== -1 && currentGongIndex > lastGongIndex) {
        const isLastGong = currentGongIndex === gongTimes.length - 1;
        playMultipleGongs(isLastGong);
        lastGongIndex = currentGongIndex;
      }
      if (currentTime >= totalDuration) {
        pause();
        currentTime = totalDuration;
      }
    }

    // Smooth UI easing toward currentTime
    const delta = currentTime - displayTime;
    displayTime += delta * (dragging ? 0.35 : EASE);
    if (Math.abs(delta) < 0.015) displayTime = currentTime; // snap when close

    draw();
    if (isPlaying) rafId = requestAnimationFrame(updateTime);
  }
  function play() {
    if (currentTime >= totalDuration) {
      currentTime = 0; pausedTime = 0; lastGongIndex = -1;
    }
    isPlaying = true;
    startTimestamp = performance.now();
    pausedTime = currentTime;
    rafId = requestAnimationFrame(updateTime);
    updateInterval = setInterval(updateButtonStates, 1000);
    draw();
  }
  function pause() {
    isPlaying = false;
    pausedTime = currentTime;
    if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
    if (updateInterval) { clearInterval(updateInterval); updateInterval = null; }
    draw();
  }

  // =====================
  // Canvas sizing
  // =====================
  function resizeCanvas() {
    const rect = dial.getBoundingClientRect();
    dial.width  = rect.width  * DPR;
    dial.height = rect.height * DPR;
    draw();
  }
  new ResizeObserver(resizeCanvas).observe(dial);

  // =====================
  // Input Handlers
  // =====================
  ffBtn.addEventListener('click', () => {
    currentTime = Math.min(currentTime + 30, totalDuration);
    pausedTime = currentTime;
    if (isPlaying) startTimestamp = performance.now();
    else syncDisplayToCurrent();
    updateButtonStates();
    draw();
  });
  rewBtn.addEventListener('click', () => {
    if (currentTime === 0) return;
    currentTime = Math.max(currentTime - 30, 0);
    pausedTime = currentTime;
    lastGongIndex = gongTimes.findIndex(t => t > currentTime) - 1;
    gongTimeouts.forEach(timeout => clearTimeout(timeout));
    gongTimeouts = [];
    if (isPlaying) startTimestamp = performance.now();
    else syncDisplayToCurrent();
    updateButtonStates();
    draw();
  });
  window.addEventListener('keydown', async (e) => {
    if (e.code === 'Space') { e.preventDefault(); await primeAudioIfNeeded(); if (isPlaying) pause(); else play(); }
    if (e.key === 'ArrowRight') { currentTime = Math.min(currentTime + 5, totalDuration); pausedTime = currentTime; if (!isPlaying) syncDisplayToCurrent(); updateButtonStates(); draw(); }
    if (e.key === 'ArrowLeft') { currentTime = Math.max(currentTime - 5, 0); pausedTime = currentTime; if (!isPlaying) syncDisplayToCurrent(); updateButtonStates(); draw(); }
  }, {capture:true});

  // Canvas interactions — fixed indicator, rotate dial while dragging
  dial.addEventListener('pointerdown', async (e) => {
    await primeAudioIfNeeded();
    const centerDistance = distanceFromCenter(e);
    const rect = dial.getBoundingClientRect();
    const cssRadius = Math.min(rect.width, rect.height) * 0.38;
    const centerRadius = cssRadius * 0.6;

    if (centerDistance < centerRadius) {
      if (isPlaying) pause(); else play();
    } else {
      dragging = true;
      const r = dial.getBoundingClientRect();
      pointerX = (e.clientX - r.left) * DPR;
      pointerY = (e.clientY - r.top)  * DPR;
      dial.setPointerCapture(e.pointerId);
      dragStartAngle = angleFromPointer(e);
      dragStartTime = currentTime;
      syncDisplayToCurrent();
    }
  });
  dial.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    const r = dial.getBoundingClientRect();
    pointerX = (e.clientX - r.left) * DPR;
    pointerY = (e.clientY - r.top)  * DPR;
    const aNow = angleFromPointer(e);
    const delta = normAngle(aNow - dragStartAngle); // [+ccw, -cw]
    const signedDelta = SCRUB_CLOCKWISE_INCREASES ? -delta : delta;
    let newTime = dragStartTime + (signedDelta / TAU) * totalDuration;
    newTime = Math.max(0, Math.min(totalDuration, newTime));
    currentTime = newTime;
    pausedTime = currentTime;
    lastGongIndex = gongTimes.findIndex(t => t > currentTime) - 1;
    gongTimeouts.forEach(timeout => clearTimeout(timeout));
    gongTimeouts = [];
    if (isPlaying) startTimestamp = performance.now();
    syncDisplayToCurrent();
    updateButtonStates();
    draw();
  });
  function stopDragging(e){ 
    if (dragging) { dragging = false; pausedTime = currentTime; if (isPlaying) startTimestamp = performance.now(); }
    try { dial.releasePointerCapture(e.pointerId); } catch(_){} 
  }
  dial.addEventListener('pointerup', stopDragging);
  dial.addEventListener('pointercancel', stopDragging);
  dial.addEventListener('pointerleave', stopDragging);

  // =====================
  // Drawing
  // =====================
  function updateButtonStates() {
    if (currentTime === 0) {
      rewBtn.classList.add('btn-disabled');
      rewBtn.disabled = true;
    } else {
      rewBtn.classList.remove('btn-disabled');
      rewBtn.disabled = false;
    }
  }

  function draw() {
    const w = dial.width, h = dial.height;
    ctx.clearRect(0,0,w,h);
    const cx = w/2, cy = h/2;
    const radius = Math.min(w,h) * 0.38;
    const ring = Math.max(12, Math.min(w,h) * 0.05);

    // Soft ambient halo
    const halo = ctx.createRadialGradient(cx, cy, radius*0.6, cx, cy, radius*1.4);
    halo.addColorStop(0, 'rgba(110,231,255,.04)');
    halo.addColorStop(1, 'rgba(110,231,255,0)');
    ctx.fillStyle = halo;
    ctx.beginPath();
    ctx.arc(cx, cy, radius*1.4, 0, TAU);
    ctx.fill();

    // Base ring (with gradient)
    const baseGrad = ctx.createLinearGradient(0, 0, 0, h);
    baseGrad.addColorStop(0, 'rgba(255,255,255,0.10)');
    baseGrad.addColorStop(1, 'rgba(255,255,255,0.05)');
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, TAU);
    ctx.lineWidth = ring;
    ctx.strokeStyle = baseGrad;
    ctx.lineCap = 'butt';
    ctx.stroke();

    const cur = Math.min(displayTime, totalDuration);
    const frac = cur / Math.max(totalDuration, 0.001);

    // Progress arc (gradient + glow)
    const progGrad = ctx.createLinearGradient(0, 0, w, 0);
    progGrad.addColorStop(0, 'rgba(110,231,255,0.95)');
    progGrad.addColorStop(1, 'rgba(68,159,239,0.95)');
    ctx.save();
    ctx.shadowColor = 'rgba(110,231,255,0.25)';
    ctx.shadowBlur = 18 * DPR;
    ctx.beginPath();
    ctx.arc(cx, cy, radius, START_ANGLE, START_ANGLE - frac*TAU, true);
    ctx.lineWidth = ring;
    ctx.lineCap = 'butt';
    ctx.strokeStyle = isPlaying ? progGrad : 'rgba(148,163,184,0.55)';
    ctx.stroke();
    ctx.restore();

    // Rotate dial graphics so current time aligns with indicator
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(-frac * TAU);

    // Minute ticks
    const minutes = Math.ceil(totalDuration/60);
    for (let m=0; m<=minutes; m++) {
      const a = START_ANGLE + Math.min(m*60, totalDuration)/Math.max(totalDuration,0.001)*TAU;
      const inner = radius - ring*0.62;
      const outer = radius + ring*0.08;
      ctx.beginPath();
      ctx.moveTo(inner*Math.cos(a), inner*Math.sin(a));
      ctx.lineTo(outer*Math.cos(a), outer*Math.sin(a));
      ctx.lineWidth = (m % 5 === 0) ? 3*DPR : 1.5*DPR;
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.stroke();
    }

    // Gong markers
    gongTimes.forEach((t) => {
      const a = START_ANGLE + Math.min(t, totalDuration)/Math.max(totalDuration,0.001)*TAU;
      const r0 = radius - ring*0.9;
      const r1 = radius + ring*0.35;
      ctx.beginPath();
      ctx.moveTo(r0*Math.cos(a), r0*Math.sin(a));
      ctx.lineTo(r1*Math.cos(a), r1*Math.sin(a));
      ctx.lineWidth = 1*DPR;
      ctx.strokeStyle = 'rgba(255,255,255,0.95)';
      ctx.stroke();
      const dotR = 2 * DPR;
      ctx.beginPath();
      ctx.arc((r1+8*DPR)*Math.cos(a), (r1+8*DPR)*Math.sin(a), dotR, 0, TAU);
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.fill();
    });

    // Rotating labels (inside dial)
    const fontSize = Math.max(10, Math.floor(w*0.02));
    ctx.fillStyle = 'rgba(233,238,247,0.75)';
    ctx.font = `${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    const innerLabelR = radius - ring * 1.3; // near the inner edge of the ring

    // start (time 0)
    {
      const a = START_ANGLE + 0.005 * TAU;
      const x = innerLabelR * Math.cos(a);
      const y = innerLabelR * Math.sin(a);
      ctx.save(); ctx.translate(x, y); ctx.rotate(Math.PI/2); ctx.fillText('start', 0, 0); ctx.restore();
    }
    // end (mirrors start toward center)
    {
      const a = START_ANGLE - 0.005 * TAU;
      const x = innerLabelR * Math.cos(a);
      const y = innerLabelR * Math.sin(a);
      ctx.save(); ctx.translate(x, y); ctx.rotate(-Math.PI/2); ctx.fillText('end', 0, 0); ctx.restore();
    }
    // half (50%)
    {
      const a = START_ANGLE + 0.5 * TAU;
      const x = innerLabelR * Math.cos(a);
      const y = innerLabelR * Math.sin(a);
      ctx.save(); ctx.translate(x, y); ctx.rotate(Math.PI/2); ctx.fillText('half', 0, 0); ctx.restore();
    }

    ctx.restore(); // end rotated dial graphics

    // Pulse FX rings (expand & fade)
    for (let i = pulses.length - 1; i >= 0; i--) {
      const age = performance.now() - pulses[i].t;
      if (age > PULSE_LIFE) { pulses.splice(i,1); continue; }
      const k = age / PULSE_LIFE; // 0..1
      const r = radius + ring*0.75 + k * (ring*1.6);
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, TAU);
      ctx.strokeStyle = `rgba(110,231,255,${0.25 * (1 - k)})`;
      ctx.lineWidth = 2 * DPR * (1 - k);
      ctx.stroke();
    }

    // Fixed indicator line at the top (glowing)
    const lineStart = radius - ring*0.7;
    const lineEnd = radius + ring*0.7;
    ctx.save();
    ctx.shadowColor = 'rgba(110,231,255,0.45)';
    ctx.shadowBlur = 10 * DPR;
    ctx.beginPath();
    ctx.moveTo(cx + lineStart*Math.cos(START_ANGLE), cy + lineStart*Math.sin(START_ANGLE));
    ctx.lineTo(cx + lineEnd*Math.cos(START_ANGLE), cy + lineEnd*Math.sin(START_ANGLE));
    ctx.lineWidth = 2*DPR;
    ctx.strokeStyle = 'rgba(110,231,255,1)';
    ctx.lineCap = 'butt';
    ctx.stroke();
    ctx.restore();

    // Next gong display
    const nextGongTime = gongTimes.find(t => t > currentTime);
    if (nextGongTime) {
      const remaining = nextGongTime - currentTime;
      const remainingSecs = Math.max(0, Math.ceil(remaining));
      const m = Math.floor(remainingSecs / 60);
      const s = remainingSecs % 60;
      const timeText = m > 0 ? `${m}m ${s}s` : `${s}s`;
      const text = `<div class="paused-note">next gong in</div> <span class="time-text">${timeText}</span>`;
      const pausedNote = !isPlaying ? `<div class="paused-note">${currentTime === 0 ? '(tap ▶ to start)' : '(paused)'}</div>` : '';
      nextGongDisplay.innerHTML = text + pausedNote;
      if (isPlaying) {
        nextGongDisplay.style.color = remaining < 30 ? 'var(--ink)' : 'var(--accent)';
      } else {
        nextGongDisplay.style.color = 'var(--muted)';
      }
      nextGongDisplay.style.display = 'block';
    } else {
      nextGongDisplay.style.display = 'none';
    }

    // Center play/pause area (inner glass)
    ctx.beginPath();
    ctx.arc(cx, cy, radius * 0.6, 0, TAU);
    const innerGrad = ctx.createRadialGradient(cx, cy, radius * 0.1, cx, cy, radius * 0.6);
    innerGrad.addColorStop(0, 'rgba(15,17,21,0.8)');
    innerGrad.addColorStop(1, 'rgba(15,17,21,0.92)');
    ctx.fillStyle = innerGrad;
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 2*DPR;
    ctx.stroke();

    // Center text
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#e9eef7';
    ctx.font = `bold ${Math.floor(w*0.075)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillText(fmt(cur), cx, cy - w*0.015);
    ctx.fillStyle = 'rgba(255,255,255,0.55)';
    ctx.font = `${Math.floor(w*0.028)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillText(`of ${fmt(totalDuration)}`, cx, cy + w*0.04);

    // Play/pause icon (with bounce when toggled)
    const iconSize = w * 0.028;
    const iconY = cy + w*0.075 + 25;
    ctx.save();
    ctx.translate(0, isPlaying ? 0 : 0);
    ctx.fillStyle = 'rgba(110,231,255,0.9)';
    if (isPlaying) {
      ctx.fillRect(cx - iconSize*0.7, iconY - iconSize*0.8, iconSize*0.5, iconSize*1.6);
      ctx.fillRect(cx + iconSize*0.2, iconY - iconSize*0.8, iconSize*0.5, iconSize*1.6);
    } else {
      ctx.beginPath();
      ctx.moveTo(cx - iconSize*0.6, iconY - iconSize*0.8);
      ctx.lineTo(cx - iconSize*0.6, iconY + iconSize*0.8);
      ctx.lineTo(cx + iconSize*0.8, iconY);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  // =====================
  // Init
  // =====================
  buildGongList();
  updateButtonStates();
  resizeCanvas();
  draw();

  // =====================
  // Self-tests (console)
  // =====================
  (function runTests(){
    const eq = (a,b,msg) => { if (a!==b) throw new Error(`Assert failed: ${msg} expected ${b}, got ${a}`); };
    const approx = (a,b,eps,msg) => { if (Math.abs(a-b) > (eps||1e-6)) throw new Error(`Approx failed: ${msg} expected ~${b}, got ${a}`); };
    try {
      eq(toSeconds('01:30'), 90, 'toSeconds 01:30');
      eq(toSeconds('00:00'), 0, 'toSeconds 00:00');
      eq(totalDuration, toSeconds('37:38'), 'totalDuration matches');
      const t = 123.456; const ang = angleForTime(t, totalDuration); const back = timeForAngle(ang, totalDuration); approx(back, t, 1e-9, 'angle<->time invertible');
      console.log('%cGong Timer tests passed','color:#0fa');
    } catch (e) {
      console.error('Gong Timer test failed:', e);
    }
  })();
})();
</script>
</body>
</html>
