<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Gong Timer — Animated UI (v2)</title>
<link rel="preload" as="audio" href="./individual_gong.mp3">
<link rel="preload" as="audio" href="./final_gongs.mp3">
<style>
  /* =====================
     Theme & Base Styles
     ===================== */
  :root {
    /* Font sizes */
    --font-xs: 13px;      /* sub text, small buttons */
    --font-sm: 14px;      /* buttons, chips */
    --font-md: 15px;      /* touch buttons */
    --font-lg: 20px;      /* corner buttons */
    --font-xl: 25px;      /* paused note */
    --font-2xl: 35px;     /* next gong display */
    --font-3xl: 55px;     /* time text */
    --font-4xl: 80px;     /* next gong display */

    /* Canvas font scale factors (multiplied by canvas width) */
    --canvas-label-scale: 0.03;     /* rotating labels inside dial */
    --canvas-time-scale: 0.11;     /* center time display */
    --canvas-subtitle-scale: 0.05; /* "of XX:XX" subtitle */

    /* Colors */
    --bg: #0b0e14;        /* deeper background */
    --bg2: #0f1420;       /* panel contrast */
    --bg3: #07090d;       /* darker gradient end */
    --ink: #e9eef7;
    --muted: #8c99ad;
    --accent: #6ee7ff;
    --accent2: #449fef;
    --glow: 0 0 24px rgba(110, 231, 255, .25);
    --canvas-ring: rgba(255,255,255,0.10);
    --canvas-ring-end: rgba(255,255,255,0.05);
    --canvas-tick: rgba(255,255,255,0.18);
    --canvas-marker: rgba(255,255,255,0.95);
    --canvas-border: rgba(255,255,255,0.08);
    --canvas-label: rgba(233,238,247,0.75);
    --canvas-subtitle: rgba(255,255,255,0.55);
  }

  [data-theme="light"] {
    --bg: #f8fafc;
    --bg2: #f1f5f9;
    --bg3: #e2e8f0;
    --ink: #1e293b;
    --muted: #64748b;
    --accent: #0284c7;
    --accent2: #0ea5e9;
    --glow: 0 0 24px rgba(2, 132, 199, .25);
    --canvas-ring: rgba(30,41,59,0.15);
    --canvas-ring-end: rgba(30,41,59,0.08);
    --canvas-tick: rgba(30,41,59,0.25);
    --canvas-marker: rgba(30,41,59,0.8);
    --canvas-border: rgba(30,41,59,0.12);
    --canvas-label: rgba(30,41,59,0.8);
    --canvas-subtitle: rgba(30,41,59,0.6);
  }
  html, body {
    height: 100%;
    background: radial-gradient(1200px 800px at 20% -10%, rgba(68,159,239,.15), transparent 60%),
                radial-gradient(1400px 900px at 110% 120%, rgba(110,231,255,.92), transparent 50%),
                linear-gradient(180deg, var(--bg), var(--bg3) 60%);
    color: var(--ink);
    margin: 0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
    overflow: hidden;
  }
  html.paused body {
    background: radial-gradient(1400px 900px at 110% 120%, rgba(190, 190, 190, 0.92), transparent 50%),
                linear-gradient(0deg, var(--bg), var(--bg3) 60%);
  }
  * { box-sizing: border-box; }

  /* =====================
     Layout & Panels (glass + subtle animation)
     ===================== */
  .wrap {
    height: 100dvh;
    max-width: 980px;
    margin: 0 auto;
    padding: 16px;
    padding-bottom: max(16px, env(safe-area-inset-bottom));
    display: flex;
    flex-direction: column;
    gap: 14px;
  }
  .panel {
    position: relative;
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 16px;
    padding: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.04);
    backdrop-filter: saturate(120%) blur(6px);
    animation: panelIn .6s cubic-bezier(.2,.8,.2,1) both;
  }
  @keyframes panelIn { from { transform: translateY(8px); opacity: 0 } }


  /* =====================
     Buttons (micro‑interaction)
     ===================== */
  button {
    appearance: none;
    background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
    border: 1px solid rgba(255,255,255,0.14);
    color: var(--ink);
    padding: 10px 14px;
    border-radius: 12px;
    cursor: pointer;
    font-weight: 700;
    font-size: var(--font-sm);
    letter-spacing: .2px;
    transition: transform .08s ease, box-shadow .2s ease, border-color .2s ease, background .2s ease;
  }
  button:hover { border-color: rgba(110,231,255,.5); box-shadow: var(--glow); }
  button:active { /* Removed transform animation - using circle effect instead */ }

  /* Touch-friendly button sizing */
  @media (pointer: coarse) {
    button {
      padding: 12px 16px;
      font-size: var(--font-md);
      min-height: 44px; /* iOS touch target minimum */
    }
    .corner-btn { min-width: 44px; }
  }
  .btn-accent { color: var(--bg3); background: linear-gradient(180deg, rgba(110,231,255,.95), rgba(68,159,239,.9)); border-color: rgba(110,231,255,.85); box-shadow: 0 6px 24px rgba(110,231,255,.3); }
  .btn-accent:hover { filter: saturate(115%); }
  .btn-disabled { opacity: 0.4; cursor: not-allowed; }
  .btn-disabled:hover { border-color: rgba(255,255,255,0.14); box-shadow: none; }


  /* =====================
     Canvas Stage
     ===================== */
  .canvas-panel {
    flex: 1;
    min-height: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }
  .next-gong-top {
    position: absolute;
    top: 2%;
    left: 50%;
    transform: translateX(-50%);
    color: var(--accent2);
    font-size: var(--font-2xl);
    font-weight: 800;
    text-align: center;
    z-index: 2;
    width: max-content;
    font-variant-numeric: tabular-nums;
    text-shadow: 0 1px 0 rgba(0,0,0,.4);
    transition: color .3s ease, transform .4s cubic-bezier(.2,.8,.2,1);
  }
  .next-gong-top.pulse { transform: translateX(-50%) scale(1.02); }
  .next-gong-text { font-size: var(--font-xl); font-weight: 600; color: var(--muted); margin-top: 10px; }
  .paused-note { font-size: var(--font-3xl); font-weight: 800; color: var(--muted); margin-top: -20px; }
  .tap-note { font-size: var(--font-xl); font-weight: 600; color: var(--muted); margin-top: 0px; }
  .time-text { font-size: var(--font-3xl); font-weight: 800; margin-top: -10px; display: block; }

  .corner-btn {
    position: absolute;
    bottom: max(20px, calc(20px + env(safe-area-inset-bottom)));
    z-index: 3;
    font-size: var(--font-lg);
    width: 90px;
    height: 90px;
    display: flex;
    align-items: end;
    justify-content: center;
    background: none;
    border: none;
    box-shadow: none;
  }
  .corner-btn:hover {
    background: none;
    border: none;
    box-shadow: none;
  }
  .corner-btn-left {
    left: 12px;
  }
  .corner-btn-right {
    right: 12px;
  }

  canvas {
    width: 100%;
    height: 100%;
    max-width: min(100%, 100dvh - 300px);
    max-height: min(100%, 100dvh - 300px);
    display: block;
    touch-action: none;
    cursor: pointer;
    object-fit: contain;
    filter: drop-shadow(0 40px 80px rgba(0,0,0,.35));
  }

  /* =====================
     Gong list chips
     ===================== */
  .sub { color: var(--muted); font-size: var(--font-xs); margin-bottom: 8px; }
  .list {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(92px, 1fr));
    gap: 8px;
  }
  .chip {
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
    border: 1px solid rgba(255,255,255,0.14);
    border-radius: 999px;
    padding: 7px 10px;
    font-variant-numeric: tabular-nums;
    text-align: center;
    cursor: pointer;
    font-size: var(--font-sm);
    transition: transform .12s ease, box-shadow .25s ease, border-color .2s ease;
    user-select: none;
  }
  .chip:hover { transform: translateY(-1px); border-color: rgba(110,231,255,.6); box-shadow: var(--glow); }
  .chip:active { transform: translateY(0); }

  .corner-btn-quarter {
    left: 65%;
    transform: translateX(-50%);
    font-size: 28px;
    line-height: 1;
  }
  .corner-btn-half {
    left: 50%;
    transform: translateX(-50%);
    font-size: 28px;
    line-height: 1;
  }
  .corner-btn-three-quarter {
    left: 35%;
    transform: translateX(-50%);
    font-size: 28px;
    line-height: 1;
  }

  /* Button click animation */
  .button-click-animation {
    position: fixed;
    pointer-events: none;
    border-radius: 50%;
    background: rgba(110, 231, 255, 0.6);
    border: 3px solid rgba(110, 231, 255, 0.8);
    transform: translate(-50%, -50%);
    animation: buttonClickExpand 400ms ease-out forwards;
    z-index: 1000;
  }

  @keyframes buttonClickExpand {
    0% {
      width: 0;
      height: 0;
      opacity: 1;
    }
    100% {
      width: 100px;
      height: 100px;
      opacity: 0;
    }
  }

  @media (max-height: 640px) {
    .sub { display: none; }
    .panel { padding: 10px; }
    button { padding: 8px 12px; font-size: var(--font-xs); }
  }
</style>
</head>
<body>
<div class="wrap">

  <div class="panel canvas-panel">
    <div id="nextGongDisplay" class="next-gong-top"></div>
    <button id="rew" class="corner-btn corner-btn-left">- 30s</button>
    <button id="ff" class="corner-btn corner-btn-right">+ 30s</button>
    <button id="quarterGong" class="corner-btn corner-btn-quarter">•••</button>
    <button id="halfGong" class="corner-btn corner-btn-half">••</button>
    <button id="threeQuarterGong" class="corner-btn corner-btn-three-quarter">•</button>
    <canvas id="dial" width="640" height="640" aria-label="Radial audio scrubber"></canvas>
  </div>

  <div class="panel" style="display: none;">
    <div class="sub">Gongs (tap to jump)</div>
    <div id="gongList" class="list"></div>
  </div>
</div>


<script>
(() => {
  // =====================
  // Config & Audio Assets
  // =====================
  const gongTimes = ["04:43","09:23","14:06","18:48","23:30","28:12","32:54","37:38"].map(toSeconds);
  const totalDuration = gongTimes[gongTimes.length - 1]; // 37:38
  const GONG_DELAY = 3880; // 3.88 seconds in milliseconds

  const GONG_POOL_SIZE = 5; // overlapping rings
  const gongPool = [];
  let gongIndex = 0;
  let audioPrimed = false;
  let finalGongAudio = null;

  // =====================
  // DOM
  // =====================
  const ffBtn = document.getElementById('ff');
  const rewBtn = document.getElementById('rew');
  const quarterGongBtn = document.getElementById('quarterGong');
  const halfGongBtn = document.getElementById('halfGong');
  const threeQuarterGongBtn = document.getElementById('threeQuarterGong');
  const dial = document.getElementById('dial');
  const ctx = dial.getContext('2d');
  const gongList = document.getElementById('gongList');
  const nextGongDisplay = document.getElementById('nextGongDisplay');

  // =====================
  // State
  // =====================
  let isPlaying = false;
  let currentTime = 0;      // logic time (audio/triggers)
  let displayTime = 0;      // eased UI time
  let startTimestamp = 0;
  let pausedTime = 0;
  let rafId = null;
  let updateInterval = null;
  let dragging = false;
  let pointerDown = false;
  let lastGongIndex = -1;
  let gongTimeouts = [];
  let pointerX = 0;
  let pointerY = 0;
  let lastAngle = 0;
  let currentPointerAngle = 0;

  // Drag rotation state (for fixed indicator UX)
  let dragStartAngle = 0; // angle at pointerdown
  let dragStartTime = 0;  // time at pointerdown

  // Easing factor for displayTime (0..1). Higher = snappier.
  const EASE = 0.18;

  // Set scrub direction preference: false => clockwise increases time (reversed from original)
  const SCRUB_CLOCKWISE_INCREASES = false;

  // Drawing metrics
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  // Pulse FX on each gong
  const pulses = []; // {t: timestamp(ms), life: 800}
  const PULSE_LIFE = 3000;

  // Play/pause animation
  const playPauseAnimations = []; // {t: timestamp(ms), isPlay: boolean}

  // Button click animations (now using DOM elements)
  const activeButtonAnimations = new Set(); // Track active animation elements

  // Animation control vars - easy to tweak!
  const ANIM_SPEED = 600;        // duration in ms
  const ANIM_SIZE = 0.4;          // max radius as fraction of canvas (0.5 = half canvas)
  const ANIM_LAYERS = 1;          // number of concentric circles (1-5)
  const ANIM_INTENSITY = 0.6;     // opacity/brightness (0.1-1.0)
  const ANIM_GLOW = 20;           // glow blur amount in pixels
  const ANIM_BOUNCE = false;       // use bounce easing vs smooth

  const PLAY_PAUSE_LIFE = ANIM_SPEED;
  // Button click animation duration matches CSS animation
  const BUTTON_CLICK_LIFE = 400;

  // =====================
  // Utilities
  // =====================
  function toSeconds(mmss) {
    const [m, s] = mmss.split(':').map(Number);
    return (m||0) * 60 + (s||0);
  }
  function hexToRgb(hex) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgb(${r}, ${g}, ${b})`;
  }
  function syncDisplayToCurrent() { displayTime = currentTime; }
  function fmt(secs) {
    secs = Math.max(0, Math.floor(secs || 0));
    const m = Math.floor(secs / 60);
    const s = secs % 60;
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }

  const TAU = Math.PI * 2;
  const START_ANGLE = -Math.PI / 2; // fixed indicator at top

  function angleForTime(time, duration) {
    return START_ANGLE + (time / Math.max(duration, 0.001)) * TAU;
  }
  function timeForAngle(angle, duration) {
    const norm = (angle - START_ANGLE + TAU) % TAU;
    return (norm / TAU) * duration;
  }
  function normAngle(a) {
    let x = (a + Math.PI) % (2*Math.PI);
    if (x < 0) x += 2*Math.PI;
    return x - Math.PI; // -> [-PI, PI)
  }
  function angleFromPointer(ev) {
    const rect = dial.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    const cx = rect.width  / 2;
    const cy = rect.height / 2;
    return Math.atan2(y - cy, x - cx);
  }
  function distanceFromCenter(ev) {
    const rect = dial.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    const cx = rect.width  / 2;
    const cy = rect.height / 2;
    return Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
  }

  // =====================
  // Audio setup
  // =====================
  function createGongPool() {
    if (gongPool.length) return; // already created
    for (let i = 0; i < GONG_POOL_SIZE; i++) {
      const a = new Audio('./individual_gong.mp3');
      a.preload = 'auto';
      gongPool.push(a);
    }
    finalGongAudio = new Audio('./final_gongs.mp3');
    finalGongAudio.preload = 'auto';
  }
  async function primeAudioIfNeeded() {
    if (audioPrimed) return;
    createGongPool();
    try {
      for (const a of gongPool) {
        a.muted = true; await a.play(); a.pause(); a.currentTime = 0; a.muted = false;
      }
      if (finalGongAudio) {
        finalGongAudio.muted = true; await finalGongAudio.play(); finalGongAudio.pause(); finalGongAudio.currentTime = 0; finalGongAudio.muted = false;
      }
      audioPrimed = true;
    } catch (err) {
      console.warn('Audio prime failed:', err);
    }
  }
  function playGongSound() {
    if (!audioPrimed || !gongPool.length) return;
    const a = gongPool[gongIndex];
    gongIndex = (gongIndex + 1) % gongPool.length;

    // Add pulse animation for each gong sound
    pulses.push({ t: performance.now() });

    try { a.currentTime = 0; a.play().catch(e => console.warn('play() blocked:', e)); }
    catch (e) { console.warn('play error:', e); }
  }
  function playMultipleGongs(isLastGong = false) {
    gongTimeouts.forEach(timeout => clearTimeout(timeout));
    gongTimeouts = [];

    // Header nudge
    nextGongDisplay.classList.add('pulse');
    setTimeout(() => nextGongDisplay.classList.remove('pulse'), 280);

    if (isLastGong && finalGongAudio) {
      try { finalGongAudio.currentTime = 0; finalGongAudio.play().catch(e => console.warn('final gong play() blocked:', e)); }
      catch (e) { console.warn('final gong play error:', e); }
    } else {
      const numGongs = 3;
      playGongSound();
      for (let i = 1; i < numGongs; i++) {
        const timeout = setTimeout(() => playGongSound(), GONG_DELAY * i);
        gongTimeouts.push(timeout);
      }
    }
  }

  // =====================
  // Build gong list (defined BEFORE use)
  // =====================
  function buildGongList() {
    gongList.innerHTML = '';
    gongTimes.forEach((sec, i) => {
      const div = document.createElement('div');
      div.className = 'chip';
      div.textContent = `${i+1} • ${fmt(sec)}`;
      div.title = 'Jump to ' + fmt(sec);
      div.addEventListener('click', async () => {
        await primeAudioIfNeeded();
        currentTime = Math.min(Math.max(sec - 0.75, 0), totalDuration);
        pausedTime = currentTime;
        lastGongIndex = i - 1; // so this one will fire naturally
        gongTimeouts.forEach(timeout => clearTimeout(timeout));
        gongTimeouts = [];
        if (isPlaying) startTimestamp = performance.now();
        else syncDisplayToCurrent();
        updateButtonStates();
        draw();
      });
      gongList.appendChild(div);
    });
  }

  // =====================
  // Timer
  // =====================
  function updateTime() {
    if (isPlaying && !dragging) {
      const elapsed = (performance.now() - startTimestamp) / 1000;
      currentTime = Math.min(pausedTime + elapsed, totalDuration);

      // Trigger gongs when crossing timestamps
      const currentGongIndex = gongTimes.findIndex(t => currentTime >= t && currentTime < t + 0.5 && lastGongIndex < gongTimes.indexOf(t));
      if (currentGongIndex !== -1 && currentGongIndex > lastGongIndex) {
        const isLastGong = currentGongIndex === gongTimes.length - 1;
        playMultipleGongs(isLastGong);
        lastGongIndex = currentGongIndex;
      }
      if (currentTime >= totalDuration) {
        pause();
        currentTime = totalDuration;
      }
    }

    // Smooth UI easing toward currentTime
    const delta = currentTime - displayTime;
    displayTime += delta * (dragging ? 0.35 : EASE);
    if (Math.abs(delta) < 0.015) displayTime = currentTime; // snap when close

    draw();

    // Keep animation loop running if playing or if there are active play/pause animations
    const hasActiveAnimations = playPauseAnimations.length > 0;
    if (isPlaying || hasActiveAnimations) rafId = requestAnimationFrame(updateTime);
  }
  function play() {
    if (currentTime >= totalDuration) {
      currentTime = 0; pausedTime = 0; lastGongIndex = -1;
    }
    isPlaying = true;
    startTimestamp = performance.now();
    pausedTime = currentTime;
    rafId = requestAnimationFrame(updateTime);
    updateInterval = setInterval(updateButtonStates, 1000);
    document.documentElement.classList.remove('paused');

    // Add play animation
    playPauseAnimations.push({ t: performance.now(), isPlay: true });

    draw();
  }
  function pause() {
    isPlaying = false;
    pausedTime = currentTime;
    if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
    if (updateInterval) { clearInterval(updateInterval); updateInterval = null; }
    document.documentElement.classList.add('paused');

    // Add pause animation
    playPauseAnimations.push({ t: performance.now(), isPlay: false });

    // Start animation loop for the pause animation
    rafId = requestAnimationFrame(updateTime);

    draw();
  }

  // =====================
  // Canvas sizing
  // =====================
  function resizeCanvas() {
    const rect = dial.getBoundingClientRect();
    dial.width  = rect.width  * DPR;
    dial.height = rect.height * DPR;
    draw();
  }
  new ResizeObserver(resizeCanvas).observe(dial);

  // =====================
  // Input Handlers
  // =====================
  ffBtn.addEventListener('click', () => {
    currentTime = Math.min(currentTime + 30, totalDuration);
    pausedTime = currentTime;
    if (isPlaying) startTimestamp = performance.now();
    else syncDisplayToCurrent();
    updateButtonStates();
    draw();
  });
  rewBtn.addEventListener('click', () => {
    if (currentTime === 0) return;
    currentTime = Math.max(currentTime - 30, 0);
    pausedTime = currentTime;
    lastGongIndex = gongTimes.findIndex(t => t > currentTime) - 1;
    gongTimeouts.forEach(timeout => clearTimeout(timeout));
    gongTimeouts = [];
    if (isPlaying) startTimestamp = performance.now();
    else syncDisplayToCurrent();
    updateButtonStates();
    draw();
  });
  quarterGongBtn.addEventListener('click', async () => {
    await primeAudioIfNeeded();
    const quarterGongTime = gongTimes[1]; // 2nd gong (09:23)
    currentTime = Math.min(Math.max(quarterGongTime + 12, 0), totalDuration);
    pausedTime = currentTime;
    lastGongIndex = 1; // so we're past the quarter gong
    gongTimeouts.forEach(timeout => clearTimeout(timeout));
    gongTimeouts = [];
    if (isPlaying) startTimestamp = performance.now();
    else syncDisplayToCurrent();
    updateButtonStates();
    draw();
  });
  halfGongBtn.addEventListener('click', async () => {
    await primeAudioIfNeeded();
    const middleGongTime = gongTimes[3]; // 4th gong (18:48)
    currentTime = Math.min(Math.max(middleGongTime + 12, 0), totalDuration);
    pausedTime = currentTime;
    lastGongIndex = 3; // so we're past the middle gong
    gongTimeouts.forEach(timeout => clearTimeout(timeout));
    gongTimeouts = [];
    if (isPlaying) startTimestamp = performance.now();
    else syncDisplayToCurrent();
    updateButtonStates();
    draw();
  });
  threeQuarterGongBtn.addEventListener('click', async () => {
    await primeAudioIfNeeded();
    const threeQuarterGongTime = gongTimes[5]; // 6th gong (28:12)
    currentTime = Math.min(Math.max(threeQuarterGongTime + 12, 0), totalDuration);
    pausedTime = currentTime;
    lastGongIndex = 5; // so we're past the three-quarter gong
    gongTimeouts.forEach(timeout => clearTimeout(timeout));
    gongTimeouts = [];
    if (isPlaying) startTimestamp = performance.now();
    else syncDisplayToCurrent();
    updateButtonStates();
    draw();
  });
  window.addEventListener('keydown', async (e) => {
    if (e.code === 'Space') { e.preventDefault(); await primeAudioIfNeeded(); if (isPlaying) pause(); else play(); }
    if (e.key === 'ArrowRight') { currentTime = Math.min(currentTime + 5, totalDuration); pausedTime = currentTime; if (!isPlaying) syncDisplayToCurrent(); updateButtonStates(); draw(); }
    if (e.key === 'ArrowLeft') { currentTime = Math.max(currentTime - 5, 0); pausedTime = currentTime; if (!isPlaying) syncDisplayToCurrent(); updateButtonStates(); draw(); }
  }, {capture:true});


  // Canvas interactions — fixed indicator, rotate dial while dragging
  dial.addEventListener('pointerdown', async (e) => {
    e.preventDefault(); // Prevent default touch behaviors
    await primeAudioIfNeeded();
    const centerDistance = distanceFromCenter(e);
    const rect = dial.getBoundingClientRect();
    const cssRadius = Math.min(rect.width, rect.height) * 0.38;
    const centerRadius = cssRadius * 0.6;

    pointerDown = true;
    if (centerDistance < centerRadius) {
      if (isPlaying) pause(); else play();
    } else {
      dragging = true;
      const r = dial.getBoundingClientRect();
      pointerX = (e.clientX - r.left) * DPR;
      pointerY = (e.clientY - r.top)  * DPR;
      // Removed pointer capture to prevent button interference
      lastAngle = angleFromPointer(e);
      currentPointerAngle = angleFromPointer(e);
      dragStartAngle = angleFromPointer(e);
      dragStartTime = currentTime;
      syncDisplayToCurrent();
    }
  });
  dial.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    const r = dial.getBoundingClientRect();
    pointerX = (e.clientX - r.left) * DPR;
    pointerY = (e.clientY - r.top)  * DPR;
    const aNow = angleFromPointer(e);
    currentPointerAngle = aNow;
    const smallDelta = normAngle(aNow - lastAngle);
    lastAngle = aNow;
    const signedSmallDelta = SCRUB_CLOCKWISE_INCREASES ? -smallDelta : smallDelta;
    const timeDelta = (signedSmallDelta / TAU) * totalDuration;
    let newTime = currentTime + timeDelta;
    newTime = Math.max(0, Math.min(totalDuration, newTime));
    currentTime = newTime;
    pausedTime = currentTime;
    lastGongIndex = gongTimes.findIndex(t => t > currentTime) - 1;
    gongTimeouts.forEach(timeout => clearTimeout(timeout));
    gongTimeouts = [];
    if (isPlaying) startTimestamp = performance.now();
    syncDisplayToCurrent();
    updateButtonStates();
    draw();
  });
  function stopDragging(e){
    pointerDown = false;
    if (dragging) {
      dragging = false;
      pausedTime = currentTime;
      if (isPlaying) startTimestamp = performance.now();
      draw(); // Force redraw to hide cursor ring
    }
  }
  dial.addEventListener('pointerup', stopDragging);
  dial.addEventListener('pointercancel', stopDragging);
  dial.addEventListener('pointerleave', stopDragging);

  // Global pointer up handler to ensure dragging state is reset
  document.addEventListener('pointerup', (e) => {
    if (dragging || pointerDown) {
      stopDragging(e);
    }
  });

  // Function to create button click animation
  function createButtonClickAnimation(element) {
    const rect = element.getBoundingClientRect();
    const x = rect.left + rect.width / 2;
    const y = rect.top + rect.height / 2;

    // Create animation element
    const animationEl = document.createElement('div');
    animationEl.className = 'button-click-animation';
    animationEl.style.left = x + 'px';
    animationEl.style.top = y + 'px';

    document.body.appendChild(animationEl);
    activeButtonAnimations.add(animationEl);

    // Remove element after animation completes
    setTimeout(() => {
      if (animationEl.parentNode) {
        animationEl.parentNode.removeChild(animationEl);
      }
      activeButtonAnimations.delete(animationEl);
    }, BUTTON_CLICK_LIFE);
  }

  // Ensure buttons always work by preventing canvas interference
  [quarterGongBtn, halfGongBtn, threeQuarterGongBtn, ffBtn, rewBtn].forEach(btn => {
    btn.addEventListener('pointerdown', (e) => {
      e.stopPropagation(); // Prevent canvas from capturing this event
      stopDragging(e); // Reset any dragging state
    });
    btn.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent canvas from interfering
      createButtonClickAnimation(btn); // Add click animation
    });
  });

  // =====================
  // Drawing
  // =====================
  function updateButtonStates() {
    if (currentTime === 0) {
      rewBtn.classList.add('btn-disabled');
      rewBtn.disabled = true;
    } else {
      rewBtn.classList.remove('btn-disabled');
      rewBtn.disabled = false;
    }
  }

  function draw() {
    const w = dial.width, h = dial.height;
    ctx.clearRect(0,0,w,h);
    const cx = w/2, cy = h/2;
    const radius = Math.min(w,h) * 0.38;
    const ring = Math.max(12, Math.min(w,h) * 0.05);

    // Soft ambient halo
    const halo = ctx.createRadialGradient(cx, cy, radius*0.6, cx, cy, radius*1.4);
    halo.addColorStop(0, 'rgba(110,231,255,.04)');
    halo.addColorStop(1, 'rgba(110,231,255,0)');
    ctx.fillStyle = halo;
    ctx.beginPath();
    ctx.arc(cx, cy, radius*1.4, 0, TAU);
    ctx.fill();

    // Base ring (with gradient)
    const baseGrad = ctx.createLinearGradient(0, 0, 0, h);
    baseGrad.addColorStop(0, getComputedStyle(document.documentElement).getPropertyValue('--canvas-ring').trim());
    baseGrad.addColorStop(1, getComputedStyle(document.documentElement).getPropertyValue('--canvas-ring-end').trim());
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, TAU);
    ctx.lineWidth = ring;
    ctx.strokeStyle = baseGrad;
    ctx.lineCap = 'butt';
    ctx.stroke();

    const cur = Math.min(displayTime, totalDuration);
    const frac = cur / Math.max(totalDuration, 0.001);


    // Progress arc (gradient + glow) - now goes clockwise
    const progGrad = ctx.createLinearGradient(0, 0, w, 0);
    progGrad.addColorStop(0, 'rgba(110,231,255,0.95)');
    progGrad.addColorStop(1, 'rgba(68,159,239,0.95)');
    ctx.save();
    ctx.shadowColor = 'rgba(110,231,255,0.25)';
    ctx.shadowBlur = 18 * DPR;
    ctx.beginPath();
    ctx.arc(cx, cy, radius, START_ANGLE, START_ANGLE + frac*TAU, false);
    ctx.lineWidth = ring;
    ctx.lineCap = 'butt';
    ctx.strokeStyle = isPlaying ? progGrad : 'rgba(148,163,184,0.55)';
    ctx.stroke();
    ctx.restore();

    // Keep dial graphics static (no rotation)
    ctx.save();
    ctx.translate(cx, cy);

    // Minute ticks (static positions)
    const minutes = Math.ceil(totalDuration/60);
    for (let m=0; m<=minutes; m++) {
      const a = START_ANGLE + Math.min(m*60, totalDuration)/Math.max(totalDuration,0.001)*TAU;
      const inner = radius - ring*0.62;
      const outer = radius + ring*0.08;
      ctx.beginPath();
      ctx.moveTo(inner*Math.cos(a), inner*Math.sin(a));
      ctx.lineTo(outer*Math.cos(a), outer*Math.sin(a));
      ctx.lineWidth = (m % 5 === 0) ? 3*DPR : 1.5*DPR;
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-tick').trim();
      ctx.stroke();
    }

    // Gong markers (static positions)
    gongTimes.forEach((t, index) => {
      const a = START_ANGLE + Math.min(t, totalDuration)/Math.max(totalDuration,0.001)*TAU;
      const r0 = radius - ring*3;
      const r1 = radius + ring*0.35;

      // Make first and halfway (4th) gong markers thicker
      const isSpecialMarker = index === 7 || index === 3; // final (index 7) and halfway (index 3)
      const lineWidth = isSpecialMarker ? 4*DPR : 1*DPR;

      ctx.beginPath();
      ctx.moveTo(r0*Math.cos(a), r0*Math.sin(a));
      ctx.lineTo(r1*Math.cos(a), r1*Math.sin(a));
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-marker').trim();
      ctx.stroke();

      // Add dots above markers
      const dotDistance = radius + ring; // Outside the dial ring
      const dotRadius = 4*DPR;
      const dotSpacing = 8*DPR;

      if (index === 1) { // Quarter mark - 3 dots
        ctx.beginPath();
        ctx.arc(dotDistance*Math.cos(a) - dotSpacing, dotDistance*Math.sin(a), dotRadius, 0, TAU);
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-marker').trim();
        ctx.fill();

        ctx.beginPath();
        ctx.arc(dotDistance*Math.cos(a), dotDistance*Math.sin(a), dotRadius, 0, TAU);
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-marker').trim();
        ctx.fill();

        ctx.beginPath();
        ctx.arc(dotDistance*Math.cos(a) + dotSpacing, dotDistance*Math.sin(a), dotRadius, 0, TAU);
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-marker').trim();
        ctx.fill();
      } else if (index === 3) { // Half mark - 2 dots
        ctx.beginPath();
        ctx.arc(dotDistance*Math.cos(a) - dotSpacing/2, dotDistance*Math.sin(a), dotRadius, 0, TAU);
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-marker').trim();
        ctx.fill();

        ctx.beginPath();
        ctx.arc(dotDistance*Math.cos(a) + dotSpacing/2, dotDistance*Math.sin(a), dotRadius, 0, TAU);
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-marker').trim();
        ctx.fill();
      } else if (index === 5) { // Three-quarter mark - 1 dot
        ctx.beginPath();
        ctx.arc(dotDistance*Math.cos(a), dotDistance*Math.sin(a), dotRadius, 0, TAU);
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-marker').trim();
        ctx.fill();
      }
    });

    // Completed segments light fill (inner area) - static positions
    const completedSegmentFill = 'rgba(110,231,255,0.1)';
    const innerRadius = radius; // Inner area where segment numbers are

    for (let i = 0; i < 8; i++) {
      let segmentStartTime, segmentEndTime;
      if (i === 0) {
        segmentStartTime = 0;
        segmentEndTime = gongTimes[0];
      } else if (i === 7) {
        segmentStartTime = gongTimes[6];
        segmentEndTime = totalDuration;
      } else {
        segmentStartTime = gongTimes[i-1];
        segmentEndTime = gongTimes[i];
      }

      // Only fill if we've passed the gong at the end of this segment
      const shouldFill = (i < 7 && currentTime > gongTimes[i]) || (i === 7 && currentTime >= totalDuration);

      if (shouldFill) {
        const startAngle = START_ANGLE + (segmentStartTime / Math.max(totalDuration, 0.001)) * TAU;
        const endAngle = START_ANGLE + (segmentEndTime / Math.max(totalDuration, 0.001)) * TAU;

        ctx.beginPath();
        ctx.moveTo(0, 0); // Center in translated context
        ctx.arc(0, 0, innerRadius, startAngle, endAngle);
        ctx.closePath();
        ctx.fillStyle = completedSegmentFill;
        ctx.fill();
      }
    }

    // Current segment light fill with ink color (static positions)
    const currentSegmentFill = isPlaying ? 'rgba(233,238,247,0.08)' : 'rgba(233,238,247,0.03)'; // ink color with low opacity
    for (let i = 0; i < 8; i++) {
      let segmentStartTime, segmentEndTime;
      if (i === 0) {
        segmentStartTime = 0;
        segmentEndTime = gongTimes[0];
      } else if (i === 7) {
        segmentStartTime = gongTimes[6];
        segmentEndTime = totalDuration;
      } else {
        segmentStartTime = gongTimes[i-1];
        segmentEndTime = gongTimes[i];
      }

      // Fill if this is the current segment (we're within its time range)
      if (currentTime >= segmentStartTime && currentTime < segmentEndTime) {
        const startAngle = START_ANGLE + (segmentStartTime / Math.max(totalDuration, 0.001)) * TAU;
        const endAngle = START_ANGLE + (segmentEndTime / Math.max(totalDuration, 0.001)) * TAU;

        ctx.beginPath();
        ctx.moveTo(0, 0); // Center in translated context
        ctx.arc(0, 0, innerRadius, startAngle, endAngle);
        ctx.closePath();
        ctx.fillStyle = currentSegmentFill;
        ctx.fill();
        break; // Only one current segment
      }
    }

    // Static labels (inside dial)
    const labelScale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--canvas-label-scale').trim());
    const fontSize = Math.max(10, Math.floor(w * labelScale));
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-label').trim();
    ctx.font = `${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    const innerLabelR = radius - ring * 1.5; // near the inner edge of the ring

    // start/end/half labels hidden for now
    // {
    //   const a = START_ANGLE + 0.006 * TAU;
    //   const x = innerLabelR * Math.cos(a);
    //   const y = innerLabelR * Math.sin(a);
    //   ctx.save(); ctx.translate(x, y); ctx.rotate(Math.PI/2); ctx.fillText('start', 0, 0); ctx.restore();
    // }
    // {
    //   const a = START_ANGLE - 0.006 * TAU;
    //   const x = innerLabelR * Math.cos(a);
    //   const y = innerLabelR * Math.sin(a);
    //   ctx.save(); ctx.translate(x, y); ctx.rotate(-Math.PI/2); ctx.fillText('end', 0, 0); ctx.restore();
    // }
    // {
    //   const a = START_ANGLE + 0.5 * TAU;
    //   const x = innerLabelR * Math.cos(a);
    //   const y = innerLabelR * Math.sin(a);
    //   ctx.save(); ctx.translate(x, y); ctx.rotate(Math.PI/2); ctx.fillText('half', 0, 0); ctx.restore();
    // }

    // Segment numbers (1-8) - static positions
    ctx.save();
    ctx.font = `bold ${20 * DPR}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    const segmentLabelR = radius - ring * 1.5; // Position further inward

    // Determine current segment based on current time
    let currentSegmentIndex = -1;
    for (let i = 0; i < 8; i++) {
      let segmentStartTime, segmentEndTime;
      if (i === 0) {
        segmentStartTime = 0;
        segmentEndTime = gongTimes[0];
      } else if (i === 7) {
        segmentStartTime = gongTimes[6];
        segmentEndTime = totalDuration;
      } else {
        segmentStartTime = gongTimes[i-1];
        segmentEndTime = gongTimes[i];
      }

      if (currentTime >= segmentStartTime && currentTime < segmentEndTime) {
        currentSegmentIndex = i;
        break;
      }
    }

    // Calculate segment positions - each segment is between two gong times
    for (let i = 0; i < 8; i++) {
      let segmentMidTime;
      if (i === 0) {
        // First segment: from start (0) to first gong
        segmentMidTime = gongTimes[0] / 2;
      } else if (i === 7) {
        // Last segment: from last gong to end
        segmentMidTime = gongTimes[6] + (totalDuration - gongTimes[6]) / 2;
      } else {
        // Middle segments: between consecutive gongs
        segmentMidTime = (gongTimes[i-1] + gongTimes[i]) / 2;
      }

      const a = START_ANGLE + Math.min(segmentMidTime, totalDuration) / Math.max(totalDuration, 0.001) * TAU;
      const x = segmentLabelR * Math.cos(a);
      const y = segmentLabelR * Math.sin(a);

      // Set color based on segment state
      if (i === currentSegmentIndex) {
        // Current segment: ink color at 1.0 opacity
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ink').trim();
      } else if (i < currentSegmentIndex) {
        // Previous segments: accent color at 1.0 opacity
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
      } else {
        // Future segments: default color at 0.35 opacity
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-label').trim().replace(/[\d.]+\)$/, '0.35)');
      }

      // Rotate each number to be perpendicular to its position on the dial
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(a + Math.PI / 2); // Rotate by angle + 90 degrees to be perpendicular
      ctx.fillText((i + 1).toString(), 0, 0);
      ctx.restore();
    }
    ctx.restore();

    ctx.restore(); // end rotated dial graphics

    // Pulse FX rings (expand & fade)
    for (let i = pulses.length - 1; i >= 0; i--) {
      const age = performance.now() - pulses[i].t;
      if (age > PULSE_LIFE) { pulses.splice(i,1); continue; }
      const k = age / PULSE_LIFE; // 0..1
      const r = radius + ring*0.75 + k * (ring*2);
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, TAU);
      ctx.strokeStyle = `rgba(110,231,255,${0.25 * (1 - k)})`;
      ctx.lineWidth = 8 * DPR * (1 - k);
      ctx.stroke();
    }

    // Play/pause animation (expanding & fading circle from center)
    for (let i = playPauseAnimations.length - 1; i >= 0; i--) {
      const age = performance.now() - playPauseAnimations[i].t;
      if (age > PLAY_PAUSE_LIFE) { playPauseAnimations.splice(i,1); continue; }
      const k = age / PLAY_PAUSE_LIFE; // 0..1

      // Different easing for play vs pause
      let easeK;
      if (playPauseAnimations[i].isPlay) {
        // Play: normal easing
        const animK = k;
        easeK = ANIM_BOUNCE ?
          (animK < 0.5 ? 4 * animK * animK * animK : 1 - Math.pow(-2 * animK + 2, 3) / 2) :
          1 - Math.pow(1 - animK, 3);
      } else {
        // Pause: start fast, end slow (gentler ease-out)
        const animK = 1 - k; // reverse time
        easeK = 1 - Math.pow(1 - animK, 2); // gentler quadratic ease-out
      }

      // Expansion size
      const maxRadius = Math.min(w, h) * ANIM_SIZE;
      const r = easeK * maxRadius;

      // Single layer animation
      ctx.save();

      const baseAlpha = playPauseAnimations[i].isPlay ? (1 - k) : k; // Pause starts from 0 opacity
      ctx.globalAlpha = baseAlpha * ANIM_INTENSITY;

      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, TAU);

      // Colors without glow effect
      if (playPauseAnimations[i].isPlay) {
        ctx.fillStyle = 'rgba(110,231,255,1)';
      } else {
        ctx.fillStyle = 'rgba(60,60,65,1)';
      }
      ctx.fill();

      // Add stroke ring
      ctx.globalAlpha = (baseAlpha * ANIM_INTENSITY) * 0.8;
      ctx.strokeStyle = playPauseAnimations[i].isPlay ?
        'rgba(110,231,255,1)' : 'rgba(30,30,35,1)';
      ctx.lineWidth = 6 * DPR;
      ctx.stroke();

      ctx.restore();
    }

    // Button click animations now handled by CSS animations on DOM elements

    // Cursor ring (rotates with current time indicator while dragging)
    if (dragging) {
      const currentTimeAngle = START_ANGLE + (displayTime / Math.max(totalDuration, 0.001)) * TAU;
      const cursorRingRadius = radius + ring * 0.8;
      const cursorRingThickness = 3 * DPR;

      // Thin outer ring
      ctx.save();
      ctx.shadowColor = 'rgba(110,231,255,0.3)';
      ctx.shadowBlur = 6 * DPR;
      ctx.beginPath();
      ctx.arc(cx, cy, cursorRingRadius, 0, TAU);
      ctx.strokeStyle = 'rgba(110,231,255,0.6)';
      ctx.lineWidth = cursorRingThickness;
      ctx.stroke();
      ctx.restore();

      // Tick marks on cursor ring (rotated with current time)
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(currentTimeAngle);

      const numTicks = 8;
      for (let i = 0; i < numTicks; i++) {
        const tickAngle = (i / numTicks) * TAU;
        const tickInner = cursorRingRadius - ring * 0.3;
        const tickOuter = cursorRingRadius + ring * 0.3;

        ctx.save();
        ctx.beginPath();
        ctx.moveTo(tickInner * Math.cos(tickAngle), tickInner * Math.sin(tickAngle));
        ctx.lineTo(tickOuter * Math.cos(tickAngle), tickOuter * Math.sin(tickAngle));
        ctx.strokeStyle = 'rgba(110,231,255,0.4)';
        ctx.lineWidth = 10 * DPR;
        ctx.stroke();
        ctx.restore();
      }

      ctx.restore();
    }

    // Moving time indicator (shows current time position around circle)
    const currentTimeAngle = START_ANGLE + (displayTime / Math.max(totalDuration, 0.001)) * TAU;
    const lineStart = radius - ring*0.7;
    const lineEnd = radius + ring*0.7;
    ctx.save();
    ctx.shadowColor = 'rgba(110,231,255,0.45)';
    ctx.shadowBlur = 10 * DPR;
    ctx.beginPath();
    ctx.moveTo(cx + lineStart*Math.cos(currentTimeAngle), cy + lineStart*Math.sin(currentTimeAngle));
    ctx.lineTo(cx + lineEnd*Math.cos(currentTimeAngle), cy + lineEnd*Math.sin(currentTimeAngle));
    ctx.lineWidth = 2*DPR;
    ctx.strokeStyle = 'rgba(110,231,255,1)';
    ctx.lineCap = 'butt';
    ctx.stroke();
    ctx.restore();

    // Next gong display
    const nextGongTime = gongTimes.find(t => t > currentTime);
    if (nextGongTime) {
      const remaining = nextGongTime - currentTime;
      const remainingSecs = Math.max(0, Math.ceil(remaining));
      const m = Math.floor(remainingSecs / 60);
      const s = remainingSecs % 60;
      const timeText = m > 0 ? `${m}m ${s}s` : `${s}s`;
      const text = `<div class="next-gong-text">next gong in</div> <span class="time-text">${timeText}</span>`;
      const pausedNote = !isPlaying ?
        (currentTime === 0 ? `<div class="tap-note">tap ▶ to start</div>` : `<div class="paused-note">paused</div>`) : '';
      nextGongDisplay.innerHTML = text + pausedNote;
      if (isPlaying) {
        // Gradually transition from accent to ink color as time gets closer
        const progress = Math.max(0, Math.min(1, (60 - remaining) / 60));
        const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
        const inkColor = getComputedStyle(document.documentElement).getPropertyValue('--ink').trim();
        nextGongDisplay.style.color = remaining <= 60 ? `color-mix(in srgb, ${inkColor} ${progress * 100}%, ${accentColor})` : accentColor;
      } else {
        nextGongDisplay.style.color = 'var(--muted)';
      }
      nextGongDisplay.style.display = 'block';
    } else {
      nextGongDisplay.style.display = 'none';
    }

    // Center play/pause area (inner glass)
    ctx.beginPath();
    ctx.arc(cx, cy, radius * 0.6, 0, TAU);
    const innerGrad = ctx.createRadialGradient(cx, cy, radius * 0.1, cx, cy, radius * 0.6);
    const bg2Color = getComputedStyle(document.documentElement).getPropertyValue('--bg2').trim();
    const bg2Rgb = bg2Color.startsWith('#') ? hexToRgb(bg2Color) : bg2Color;

    if (isPlaying) {
      innerGrad.addColorStop(0, bg2Rgb.replace('rgb(', 'rgba(').replace(')', ',0.8)'));
      innerGrad.addColorStop(1, bg2Rgb.replace('rgb(', 'rgba(').replace(')', ',0.92)'));
    } else {
      // Greyed out when paused
      innerGrad.addColorStop(0, bg2Rgb.replace('rgb(', 'rgba(').replace(')', ',0.8)'));
      innerGrad.addColorStop(1, bg2Rgb.replace('rgb(', 'rgba(').replace(')', ',0.92)'));
    }
    ctx.fillStyle = innerGrad;
    ctx.fill();
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-border').trim();
    ctx.lineWidth = 2*DPR;
    ctx.stroke();

    // Center text
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ink').trim();
    const timeScale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--canvas-time-scale').trim());
    ctx.font = `bold ${Math.floor(w * timeScale)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.save();
    ctx.globalAlpha = isPlaying ? 1 : 0.6;
    ctx.fillText(fmt(cur), cx, cy - w*0.035);
    ctx.restore();
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-subtitle').trim();
    const subtitleScale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--canvas-subtitle-scale').trim());
    ctx.font = `${Math.floor(w * subtitleScale)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillText(`of ${fmt(totalDuration)}`, cx, cy + w*0.04);

    // Play/pause icon (with bounce when toggled)
    const iconSize = w * 0.028;
    const iconY = cy + w*0.075 + 25;
    ctx.save();
    ctx.translate(0, isPlaying ? 0 : 0);
    ctx.fillStyle = 'rgba(110,231,255,0.9)';
    if (isPlaying) {
      ctx.fillRect(cx - iconSize*0.7, iconY - iconSize*0.8, iconSize*0.5, iconSize*1.6);
      ctx.fillRect(cx + iconSize*0.2, iconY - iconSize*0.8, iconSize*0.5, iconSize*1.6);
    } else {
      ctx.beginPath();
      ctx.moveTo(cx - iconSize*0.6, iconY - iconSize*0.8);
      ctx.lineTo(cx - iconSize*0.6, iconY + iconSize*0.8);
      ctx.lineTo(cx + iconSize*0.8, iconY);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  // =====================
  // Init
  // =====================
  // Set dark mode as default and paused state
  document.documentElement.setAttribute('data-theme', 'dark');
  document.documentElement.classList.add('paused');

  buildGongList();
  updateButtonStates();
  resizeCanvas();
  draw();

  // =====================
  // Self-tests (console)
  // =====================
  (function runTests(){
    const eq = (a,b,msg) => { if (a!==b) throw new Error(`Assert failed: ${msg} expected ${b}, got ${a}`); };
    const approx = (a,b,eps,msg) => { if (Math.abs(a-b) > (eps||1e-6)) throw new Error(`Approx failed: ${msg} expected ~${b}, got ${a}`); };
    try {
      eq(toSeconds('01:30'), 90, 'toSeconds 01:30');
      eq(toSeconds('00:00'), 0, 'toSeconds 00:00');
      eq(totalDuration, toSeconds('37:38'), 'totalDuration matches');
      const t = 123.456; const ang = angleForTime(t, totalDuration); const back = timeForAngle(ang, totalDuration); approx(back, t, 1e-9, 'angle<->time invertible');
      console.log('%cGong Timer tests passed','color:#0fa');
    } catch (e) {
      console.error('Gong Timer test failed:', e);
    }
  })();
})();
</script>
</body>
</html>
