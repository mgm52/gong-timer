<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Gong Timer — Interactive Player (Fixed Indicator)</title>
<link rel="preload" as="audio" href="./individual_gong.mp3">
<link rel="preload" as="audio" href="./final_gongs.mp3">
<style>
  :root {
    --bg: #0f1115;
    --ink: #e9eef7;
    --muted: #768293;
    --accent: #6ee7ff;
    --accent2:#449fef;
  }
  html, body {
    height: 100%;
    background: var(--bg);
    color: var(--ink);
    margin: 0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
    overflow: hidden;
  }
  .wrap {
    height: 100vh;
    max-width: 920px;
    margin: 0 auto;
    padding: 8px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    box-sizing: border-box;
  }
  .panel {
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 12px;
    padding: 10px;
    box-sizing: border-box;
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
  }
  button {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.12);
    color: var(--ink);
    padding: 8px 12px;
    border-radius: 10px;
    cursor: pointer;
    font-weight: 600;
    font-size: 14px;
  }
  button:active { transform: translateY(1px); }
  .time-readout {
    font-variant-numeric: tabular-nums;
    font-size: 24px;
    font-weight: 700;
    letter-spacing: .5px;
  }
  .sub { color: var(--muted); font-size: 13px; margin-bottom: 6px; }
  .list {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
    gap: 6px;
  }
  .chip {
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 999px;
    padding: 6px 8px;
    font-variant-numeric: tabular-nums;
    text-align: center;
    cursor: pointer;
    font-size: 13px;
  }
  .hint { 
    color: var(--muted); 
    font-size: 11px; 
    text-align: center;
    display: none;
  }
  .canvas-panel {
    flex: 1;
    min-height: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
  }
  .next-gong-top {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    color: var(--accent2);
    font-size: 24px;
    font-weight: 700;
    text-align: center;
    z-index: 1;
    font-variant-numeric: tabular-nums;
  }
  .paused-note {
    font-size: 24px; /* match next-gong text size */
    font-weight: 600;
    color: var(--muted);
    margin-top: 2px;
  }
  canvas { 
    width: 100%;
    height: 100%;
    max-width: min(100%, 100vh - 280px);
    max-height: min(100%, 100vh - 280px);
    display: block; 
    touch-action: none; 
    cursor: pointer;
    object-fit: contain;
  }
  .next-gong {
    text-align: center;
    margin-top: 8px;
    color: var(--accent2);
    font-size: 14px;
    font-weight: 600;
  }
  @media (min-width: 640px) {
    .wrap {
      padding: 16px;
      gap: 12px;
    }
    .panel {
      padding: 14px;
      border-radius: 14px;
    }
    .hint { display: block; }
    button { font-size: 15px; padding: 9px 14px; }
    .chip { font-size: 14px; padding: 7px 10px; }
  }
  @media (max-height: 600px) {
    .sub { display: none; }
    .panel { padding: 8px; }
    button { padding: 6px 10px; font-size: 13px; }
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="panel controls">
    <button id="start">Restart</button>
    <div style="display:flex; gap:6px; align-items:center;">
      <button id="rew">⟲ -10s</button>
      <button id="ff">+10s ⟲</button>
    </div>
    <span class="hint">Click center to play/pause • Drag ring to rotate dial (indicator stays at top)</span>
  </div>

  <div class="panel canvas-panel">
    <div id="nextGongDisplay" class="next-gong-top"></div>
    <canvas id="dial" width="640" height="640" aria-label="Radial audio scrubber"></canvas>
  </div>

  <div class="panel">
    <div class="sub">Gongs (tap to jump)</div>
    <div id="gongList" class="list"></div>
  </div>
</div>

<script>
(() => {
  // =====================
  // Config & Audio Assets
  // =====================
  const gongTimes = ["04:43","09:23","14:06","18:48","23:30","28:12","32:54","37:38"].map(toSeconds);
  const totalDuration = gongTimes[gongTimes.length - 1]; // 37:38
  const GONG_DELAY = 3880; // 3.88 seconds in milliseconds

  const GONG_POOL_SIZE = 5; // overlapping rings
  const gongPool = [];
  let gongIndex = 0;
  let audioPrimed = false;
  let finalGongAudio = null;

  // =====================
  // DOM
  // =====================
  const startBtn = document.getElementById('start');
  const ffBtn = document.getElementById('ff');
  const rewBtn = document.getElementById('rew');
  const dial = document.getElementById('dial');
  const ctx = dial.getContext('2d');
  const gongList = document.getElementById('gongList');
  const nextGongDisplay = document.getElementById('nextGongDisplay');

  // =====================
  // State
  // =====================
  let isPlaying = false;
  let currentTime = 0;
  let startTimestamp = 0;
  let pausedTime = 0;
  let rafId = null;
  let dragging = false;
  let lastGongIndex = -1;
  let gongTimeouts = [];
  let pointerX = 0;
  let pointerY = 0;

  // Drag rotation state (for fixed indicator UX)
  let dragStartAngle = 0; // angle at pointerdown
  let dragStartTime = 0;  // time at pointerdown

  // Set scrub direction preference: true => clockwise increases time
  const SCRUB_CLOCKWISE_INCREASES = true;

  // Drawing metrics
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  // =====================
  // Utilities
  // =====================
  function toSeconds(mmss) {
    const [m, s] = mmss.split(':').map(Number);
    return (m||0) * 60 + (s||0);
  }
  function fmt(secs) {
    secs = Math.max(0, Math.floor(secs || 0));
    const m = Math.floor(secs / 60);
    const s = secs % 60;
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }

  const TAU = Math.PI * 2;
  const START_ANGLE = -Math.PI / 2; // fixed indicator at top

  function angleForTime(time, duration) {
    return START_ANGLE + (time / Math.max(duration, 0.001)) * TAU;
  }
  function timeForAngle(angle, duration) {
    const norm = (angle - START_ANGLE + TAU) % TAU;
    return (norm / TAU) * duration;
  }
  function normAngle(a) {
    let x = (a + Math.PI) % (2*Math.PI);
    if (x < 0) x += 2*Math.PI;
    return x - Math.PI; // -> [-PI, PI)
  }
  function angleFromPointer(ev) {
    const rect = dial.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    const cx = rect.width  / 2;
    const cy = rect.height / 2;
    return Math.atan2(y - cy, x - cx);
  }
  function distanceFromCenter(ev) {
    const rect = dial.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    const cx = rect.width  / 2;
    const cy = rect.height / 2;
    return Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
  }

  // =====================
  // Audio setup
  // =====================
  function createGongPool() {
    if (gongPool.length) return; // already created
    for (let i = 0; i < GONG_POOL_SIZE; i++) {
      const a = new Audio('./individual_gong.mp3');
      a.preload = 'auto';
      gongPool.push(a);
    }
    finalGongAudio = new Audio('./final_gongs.mp3');
    finalGongAudio.preload = 'auto';
  }
  async function primeAudioIfNeeded() {
    if (audioPrimed) return;
    createGongPool();
    try {
      for (const a of gongPool) {
        a.muted = true; await a.play(); a.pause(); a.currentTime = 0; a.muted = false;
      }
      if (finalGongAudio) {
        finalGongAudio.muted = true; await finalGongAudio.play(); finalGongAudio.pause(); finalGongAudio.currentTime = 0; finalGongAudio.muted = false;
      }
      audioPrimed = true;
    } catch (err) {
      console.warn('Audio prime failed:', err);
    }
  }
  function playGongSound() {
    if (!audioPrimed || !gongPool.length) return;
    const a = gongPool[gongIndex];
    gongIndex = (gongIndex + 1) % gongPool.length;
    try { a.currentTime = 0; a.play().catch(e => console.warn('play() blocked:', e)); }
    catch (e) { console.warn('play error:', e); }
  }
  function playMultipleGongs(isLastGong = false) {
    gongTimeouts.forEach(timeout => clearTimeout(timeout));
    gongTimeouts = [];
    if (isLastGong && finalGongAudio) {
      try { finalGongAudio.currentTime = 0; finalGongAudio.play().catch(e => console.warn('final gong play() blocked:', e)); }
      catch (e) { console.warn('final gong play error:', e); }
    } else {
      const numGongs = 3;
      playGongSound();
      for (let i = 1; i < numGongs; i++) {
        const timeout = setTimeout(() => playGongSound(), GONG_DELAY * i);
        gongTimeouts.push(timeout);
      }
    }
  }

  // =====================
  // Build gong list (defined BEFORE use)
  // =====================
  function buildGongList() {
    gongList.innerHTML = '';
    gongTimes.forEach((sec, i) => {
      const div = document.createElement('div');
      div.className = 'chip';
      div.textContent = `${i+1} • ${fmt(sec)}`;
      div.title = 'Jump to ' + fmt(sec);
      div.addEventListener('click', async () => {
        await primeAudioIfNeeded();
        currentTime = Math.min(Math.max(sec - 0.75, 0), totalDuration);
        pausedTime = currentTime;
        lastGongIndex = i - 1; // so this one will fire naturally
        gongTimeouts.forEach(timeout => clearTimeout(timeout));
        gongTimeouts = [];
        if (isPlaying) startTimestamp = performance.now();
        draw();
      });
      gongList.appendChild(div);
    });
  }

  // =====================
  // Timer
  // =====================
  function updateTime() {
    if (isPlaying && !dragging) {
      const elapsed = (performance.now() - startTimestamp) / 1000;
      currentTime = Math.min(pausedTime + elapsed, totalDuration);
      const currentGongIndex = gongTimes.findIndex(t => currentTime >= t && currentTime < t + 0.5 && lastGongIndex < gongTimes.indexOf(t));
      if (currentGongIndex !== -1 && currentGongIndex > lastGongIndex) {
        const isLastGong = currentGongIndex === gongTimes.length - 1;
        playMultipleGongs(isLastGong);
        lastGongIndex = currentGongIndex;
      }
      if (currentTime >= totalDuration) {
        pause();
        currentTime = totalDuration;
      }
    }
    draw();
    if (isPlaying) rafId = requestAnimationFrame(updateTime);
  }
  function play() {
    if (currentTime >= totalDuration) {
      currentTime = 0; pausedTime = 0; lastGongIndex = -1;
    }
    isPlaying = true;
    startTimestamp = performance.now();
    pausedTime = currentTime;
    rafId = requestAnimationFrame(updateTime);
    draw();
  }
  function pause() {
    isPlaying = false;
    pausedTime = currentTime;
    if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
    draw();
  }

  // =====================
  // Canvas sizing
  // =====================
  function resizeCanvas() {
    const rect = dial.getBoundingClientRect();
    dial.width  = rect.width  * DPR;
    dial.height = rect.height * DPR;
    draw();
  }
  new ResizeObserver(resizeCanvas).observe(dial);

  // =====================
  // Input Handlers
  // =====================
  startBtn.addEventListener('click', async () => {
    await primeAudioIfNeeded();
    currentTime = 0; pausedTime = 0; lastGongIndex = -1;
    gongTimeouts.forEach(timeout => clearTimeout(timeout));
    gongTimeouts = [];
    if (!isPlaying) play();
  });
  ffBtn.addEventListener('click', () => {
    currentTime = Math.min(currentTime + 10, totalDuration);
    pausedTime = currentTime;
    if (isPlaying) startTimestamp = performance.now();
    draw();
  });
  rewBtn.addEventListener('click', () => {
    currentTime = Math.max(currentTime - 10, 0);
    pausedTime = currentTime;
    lastGongIndex = gongTimes.findIndex(t => t > currentTime) - 1;
    gongTimeouts.forEach(timeout => clearTimeout(timeout));
    gongTimeouts = [];
    if (isPlaying) startTimestamp = performance.now();
    draw();
  });
  window.addEventListener('keydown', async (e) => {
    if (e.code === 'Space') { e.preventDefault(); await primeAudioIfNeeded(); if (isPlaying) pause(); else play(); }
  }, {capture:true});

  // Canvas interactions — fixed indicator, rotate dial while dragging
  dial.addEventListener('pointerdown', async (e) => {
    await primeAudioIfNeeded();
    const centerDistance = distanceFromCenter(e);
    const rect = dial.getBoundingClientRect();
    const cssRadius = Math.min(rect.width, rect.height) * 0.38;
    const centerRadius = cssRadius * 0.6;

    if (centerDistance < centerRadius) {
      if (isPlaying) pause(); else play();
    } else {
      dragging = true;
      const r = dial.getBoundingClientRect();
      pointerX = (e.clientX - r.left) * DPR;
      pointerY = (e.clientY - r.top)  * DPR;
      dial.setPointerCapture(e.pointerId);
      dragStartAngle = angleFromPointer(e);
      dragStartTime = currentTime;
    }
  });
  dial.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    const r = dial.getBoundingClientRect();
    pointerX = (e.clientX - r.left) * DPR;
    pointerY = (e.clientY - r.top)  * DPR;
    const aNow = angleFromPointer(e);
    const delta = normAngle(aNow - dragStartAngle); // [+ccw, -cw]
    const signedDelta = SCRUB_CLOCKWISE_INCREASES ? -delta : delta;
    let newTime = dragStartTime + (signedDelta / TAU) * totalDuration;
    newTime = Math.max(0, Math.min(totalDuration, newTime));
    currentTime = newTime;
    pausedTime = currentTime;
    lastGongIndex = gongTimes.findIndex(t => t > currentTime) - 1;
    gongTimeouts.forEach(timeout => clearTimeout(timeout));
    gongTimeouts = [];
    if (isPlaying) startTimestamp = performance.now();
    draw();
  });
  function stopDragging(e){ 
    if (dragging) { dragging = false; pausedTime = currentTime; if (isPlaying) startTimestamp = performance.now(); }
    try { dial.releasePointerCapture(e.pointerId); } catch(_){} 
  }
  dial.addEventListener('pointerup', stopDragging);
  dial.addEventListener('pointercancel', stopDragging);
  dial.addEventListener('pointerleave', stopDragging);

  // =====================
  // Drawing
  // =====================
  function draw() {
    const w = dial.width, h = dial.height;
    ctx.clearRect(0,0,w,h);
    const cx = w/2, cy = h/2;
    const radius = Math.min(w,h) * 0.38;
    const ring = Math.max(12, Math.min(w,h) * 0.05);

    // Base ring
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, TAU);
    ctx.lineWidth = ring;
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.stroke();

    const cur = Math.min(currentTime, totalDuration);
    const frac = cur / Math.max(totalDuration, 0.001);

    // Progress arc: from top anticlockwise
    ctx.beginPath();
    ctx.arc(cx, cy, radius, START_ANGLE, START_ANGLE - frac*TAU, true);
    ctx.lineWidth = ring;
    ctx.lineCap = 'butt';
    ctx.strokeStyle = isPlaying ? 'rgba(110,231,255,0.9)' : 'rgba(148,163,184,0.6)';
    ctx.stroke();

    // Rotate dial graphics so current time aligns with indicator
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(-frac * TAU);

    // Minute ticks
    const minutes = Math.ceil(totalDuration/60);
    for (let m=0; m<=minutes; m++) {
      const a = START_ANGLE + Math.min(m*60, totalDuration)/Math.max(totalDuration,0.001)*TAU;
      const inner = radius - ring*0.6;
      const outer = radius + ring*0.1;
      ctx.beginPath();
      ctx.moveTo(inner*Math.cos(a), inner*Math.sin(a));
      ctx.lineTo(outer*Math.cos(a), outer*Math.sin(a));
      ctx.lineWidth = (m % 5 === 0) ? 3*DPR : 1.5*DPR;
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.stroke();
    }

    // Gong markers
    gongTimes.forEach((t) => {
      const a = START_ANGLE + Math.min(t, totalDuration)/Math.max(totalDuration,0.001)*TAU;
      const r0 = radius - ring*0.9;
      const r1 = radius + ring*0.35;
      ctx.beginPath();
      ctx.moveTo(r0*Math.cos(a), r0*Math.sin(a));
      ctx.lineTo(r1*Math.cos(a), r1*Math.sin(a));
      ctx.lineWidth = 1*DPR;
      ctx.strokeStyle = 'rgba(255,255,255,0.95)';
      ctx.stroke();
      const dotR = 5 * DPR;
      ctx.beginPath();
      ctx.arc((r1+8*DPR)*Math.cos(a), (r1+8*DPR)*Math.sin(a), dotR, 0, TAU);
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.fill();
    });

    // Rotating labels (inside dial)
    const fontSize = Math.max(10, Math.floor(w*0.02));
    ctx.fillStyle = 'rgba(233,238,247,0.75)';
    ctx.font = `${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    const innerLabelR = radius - ring * 1.3; // near the inner edge of the ring

    // start (time 0)
    {
      const a = START_ANGLE + 0.005 * TAU;
      const x = innerLabelR * Math.cos(a);
      const y = innerLabelR * Math.sin(a);
      ctx.save(); ctx.translate(x, y); ctx.rotate(Math.PI/2); ctx.fillText('start', 0, 0); ctx.restore();
    }
    // end (mirrors start toward center)
    {
      const a = START_ANGLE - 0.005 * TAU;
      const x = innerLabelR * Math.cos(a);
      const y = innerLabelR * Math.sin(a);
      ctx.save(); ctx.translate(x, y); ctx.rotate(-Math.PI/2); ctx.fillText('end', 0, 0); ctx.restore();
    }
    // half (50%)
    {
      const a = START_ANGLE + 0.5 * TAU;
      const x = innerLabelR * Math.cos(a);
      const y = innerLabelR * Math.sin(a);
      ctx.save(); ctx.translate(x, y); ctx.rotate(Math.PI/2); ctx.fillText('half', 0, 0); ctx.restore();
    }

    ctx.restore(); // end rotated dial graphics

    // Fixed indicator line at the top
    const lineStart = radius - ring*0.7;
    const lineEnd = radius + ring*0.7;
    ctx.beginPath();
    ctx.moveTo(cx + lineStart*Math.cos(START_ANGLE), cy + lineStart*Math.sin(START_ANGLE));
    ctx.lineTo(cx + lineEnd*Math.cos(START_ANGLE), cy + lineEnd*Math.sin(START_ANGLE));
    ctx.lineWidth = 1*DPR;
    ctx.strokeStyle = 'rgba(110,231,255,1)';
    ctx.lineCap = 'round';
    ctx.stroke();

    // Next gong display
    const nextGongTime = gongTimes.find(t => t > currentTime);
    if (nextGongTime) {
      const remaining = nextGongTime - currentTime;
      const remainingSecs = Math.max(0, Math.floor(remaining));
      const m = Math.floor(remainingSecs / 60);
      const s = remainingSecs % 60;
      const timeText = m > 0 ? `${m}m ${s}s` : `${s}s`;
      const text = `Next gong will play in ${timeText}`;
      const pausedNote = !isPlaying ? '<div class="paused-note">(paused)</div>' : '';
      nextGongDisplay.innerHTML = text + pausedNote;
      if (isPlaying) {
        nextGongDisplay.style.color = remaining < 30 ? 'var(--ink)' : 'var(--accent)';
      } else {
        nextGongDisplay.style.color = 'var(--muted)';
      }
      nextGongDisplay.style.display = 'block';
    } else {
      nextGongDisplay.style.display = 'none';
    }

    // Center play/pause area
    ctx.beginPath();
    ctx.arc(cx, cy, radius * 0.6, 0, TAU);
    ctx.fillStyle = 'rgba(15,17,21,0.85)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.lineWidth = 2*DPR;
    ctx.stroke();

    // Center text
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#e9eef7';
    ctx.font = `bold ${Math.floor(w*0.055)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillText(fmt(cur), cx, cy - w*0.015);
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = `${Math.floor(w*0.028)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillText(`of ${fmt(totalDuration)}`, cx, cy + w*0.04);

    // Play/pause icon
    const iconSize = w * 0.028;
    const iconY = cy + w*0.075 + 25; // moved to +25
    ctx.fillStyle = 'rgba(110,231,255,0.85)';
    if (isPlaying) {
      ctx.fillRect(cx - iconSize*0.7, iconY - iconSize*0.8, iconSize*0.5, iconSize*1.6);
      ctx.fillRect(cx + iconSize*0.2, iconY - iconSize*0.8, iconSize*0.5, iconSize*1.6);
    } else {
      ctx.beginPath();
      ctx.moveTo(cx - iconSize*0.6, iconY - iconSize*0.8);
      ctx.lineTo(cx - iconSize*0.6, iconY + iconSize*0.8);
      ctx.lineTo(cx + iconSize*0.8, iconY);
      ctx.closePath();
      ctx.fill();
    }
  }

  // =====================
  // Init
  // =====================
  buildGongList();
  resizeCanvas();
  draw();

  // =====================
  // Self-tests (console)
  // =====================
  (function runTests(){
    const eq = (a,b,msg) => { if (a!==b) throw new Error(`Assert failed: ${msg} expected ${b}, got ${a}`); };
    const approx = (a,b,eps,msg) => { if (Math.abs(a-b) > (eps||1e-6)) throw new Error(`Approx failed: ${msg} expected ~${b}, got ${a}`); };
    try {
      eq(toSeconds('01:30'), 90, 'toSeconds 01:30');
      eq(toSeconds('00:00'), 0, 'toSeconds 00:00');
      eq(totalDuration, toSeconds('37:38'), 'totalDuration matches');
      const t = 123.456; const ang = angleForTime(t, totalDuration); const back = timeForAngle(ang, totalDuration); approx(back, t, 1e-9, 'angle<->time invertible');
      console.log('%cGong Timer tests passed','color:#0fa');
    } catch (e) {
      console.error('Gong Timer test failed:', e);
    }
  })();
})();
</script>
</body>
</html>
